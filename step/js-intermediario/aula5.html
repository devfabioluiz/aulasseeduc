<!DOCTYPE html>
<html lang="pt-BR">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Aula 5 - JS Intermediário</title>
    <link rel="stylesheet" href="../../estilos/estilos-aulas.css" />
  </head>
  <body>
    <header>
      <h1>Aula 5</h1>
      <h4 style="text-align: center">JavaScript Intermediário</h4>
      <h4 style="text-align: center">EcmaScript, Módulos e Funções</h4>
    </header>
    <div class="container">
      <div id="texto-imprimir">
        <h3>Escopo de Variáveis e a Palavra-chave <code>this</code></h3>
        <p>
          O escopo de variáveis refere-se à acessibilidade de variáveis em
          diferentes partes do código. Em JavaScript, existem três tipos
          principais de escopo:
        </p>
        <ul>
          <li>
            <b>Global:</b> Variáveis declaradas fora de qualquer função ou
            bloco.
          </li>
          <li>
            <b>De função:</b> Variáveis declaradas dentro de uma função só podem
            ser acessadas dentro dela.
          </li>
          <li>
            <b>De bloco:</b> Variáveis declaradas com <code>let</code> ou
            <code>const</code> dentro de um bloco (<code>{}</code>).
          </li>
        </ul>
        <p>
          A palavra-chave <code>this</code> representa o objeto ao qual a função
          atual pertence. Seu valor depende de onde e como a função foi chamada:
        </p>
        <ul>
          <li>
            Em um método de objeto, <code>this</code> refere-se ao objeto pai.
          </li>
          <li>
            Em uma função regular, <code>this</code> é <code>undefined</code> no
            modo estrito ou o objeto global fora dele.
          </li>
          <li>
            Em funções de seta, <code>this</code> é herdado do contexto lexical.
          </li>
        </ul>

        <h3>Recursão</h3>
        <p>
          Recursão é a técnica onde uma função chama a si mesma para resolver
          problemas dividindo-os em subproblemas menores. Um exemplo clássico é
          o cálculo do fatorial:
        </p>
        <pre>
          <code>
function fatorial(n) {
  if (n === 0) return 1;
  return n * fatorial(n - 1);
}
          </code>
        </pre>
        <p>
          A recursão requer uma condição de parada para evitar loops infinitos e
          estouro de pilha.
        </p>
      </div>

      <div id="texto-imprimir">
        <h2>ECMAScript</h2>
        <p>
          ECMAScript é a especificação padrão para JavaScript, criada pela ECMA
          International em 1997. Suas principais edições trouxeram recursos
          como:
        </p>
        <ul>
          <li>ES5 (2009): Estrito, JSON nativo, métodos array.</li>
          <li>
            ES6 (2015): Funções de seta, classes, <code>let</code> e
            <code>const</code>, entre outros.
          </li>
        </ul>

        <h3>Funções de Seta (Arrow Function)</h3>
        <p>
          Funções de seta introduzem uma sintaxe curta para escrever funções.
          Além disso, elas não têm seu próprio <code>this</code>, herdando do
          contexto ao redor.
        </p>
        <pre>
          <code>
const soma = (a, b) => a + b;
console.log(soma(2, 3)); // 5
          </code>
        </pre>
      </div>
      <div class="texto-imprimir">
        <h3>Diferença entre Arrow Function e Função Normal</h3>
        <p>
          Funções em JavaScript podem ser declaradas de diferentes formas, sendo
          as mais comuns a função normal e a arrow function. Ambas possuem
          diferenças importantes em sintaxe e comportamento.
        </p>

        <h3>Sintaxe</h3>
        <p>
          A principal diferença inicial é a forma como as funções são escritas:
        </p>
        <ul>
          <li>
            <b>Função Normal:</b> É escrita com a palavra-chave
            <code>function</code>:
          </li>
        </ul>
        <pre>
          <code>
function soma(a, b) {
  return a + b;
}
console.log(soma(2, 3)); // Saída: 5
          </code>
        </pre>
        <ul>
          <li>
            <b>Arrow Function:</b> Usa uma sintaxe mais curta, com
            <code>=></code>:
          </li>
        </ul>
        <pre>
          <code>
const soma = (a, b) => a + b;
console.log(soma(2, 3)); // Saída: 5
          </code>
        </pre>

        <h3>Comportamento do <code>this</code></h3>
        <p>
          O comportamento do <code>this</code> é uma das principais diferenças:
        </p>
        <ul>
          <li>
            <b>Função Normal:</b> O <code>this</code> é dinâmico, dependendo do
            contexto em que a função foi chamada.
          </li>
        </ul>
        <pre>
          <code>
const obj = {
  valor: 10,
  funcaoNormal: function () {
    return this.valor;
  },
};
console.log(obj.funcaoNormal()); // Saída: 10
          </code>
        </pre>
        <ul>
          <li>
            <b>Arrow Function:</b> O <code>this</code> é léxico, herdando o
            contexto onde a função foi definida.
          </li>
        </ul>
        <pre>
          <code>
const obj = {
  valor: 10,
  arrowFunction: () => {
    return this.valor;
  },
};
console.log(obj.arrowFunction()); // Saída: undefined
          </code>
        </pre>

        <h3>Uso como Construtor</h3>
        <p>Apenas funções normais podem ser usadas como construtores:</p>
        <pre>
          <code>
// Função Normal
function Pessoa(nome) {
  this.nome = nome;
}
const pessoa1 = new Pessoa("João");
console.log(pessoa1.nome); // Saída: João

// Arrow Function
const Pessoa = (nome) => {
  this.nome = nome;
};
const pessoa1 = new Pessoa("João"); // Erro: Pessoa não é um construtor
          </code>
        </pre>
      </div>
    </div>
    <div class="button-container">
      <button class="btn-print" onclick="window.print()">Imprimir</button>
    </div>
    <div class="button-container">
      <a class="btn-indice" href="../indice-step.html"> Ir para índice </a>
    </div>
  </body>
</html>
